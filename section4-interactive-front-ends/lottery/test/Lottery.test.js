// import node.js library that allows us to run tests
const assert = require("assert");

// serves as our local ethereum test network
const ganache = require("ganache-cli");

// note Web3 is uppercase!! bec. we are importing a constructor function
//   used to create instances of the web3 library
const Web3 = require("web3");

// create an instance of Web3, pass in a PROVIDER
// PROVIDER = way to communicate between a web3 instance and a specific ethereum network
const web3 = new Web3(ganache.provider());

// import compiled smart contract output and destructure object
const { interface, bytecode } = require("../compile");

// MOCHA TESTING
let lottery; // instance of our contract
let accounts; // all unlocked accounts/generated by ganache-cli

// cb will run before each it block
beforeEach(async () => {
  // Get a list of all accounts (unlocked = can freely send/receive ether)
  accounts = await web3.eth.getAccounts();
  // => returns a promise that resolves to a list of accounts

  // Use one of those accounts to deploy the contract
  // create a JS instance of a contract
  // - interface tells web3 what methods the Inbox contract has
  // - has a methods property (with methods defined in the .sol file)
  // - has options property (with info about the contract like address, gasPrice, gas, ...)
  lottery = await new web3.eth.Contract(JSON.parse(interface))

    // tells web3 that we want to deploy a new contract
    // - data and arguments are properties of a transaction object
    // - arguments is list of arguments thats passed into contructor function of contract
    .deploy({ data: bytecode }) //=> transaction object

    // tells web3 to send out a transaction that creates this contract
    // - gas = quantity of how much it'll cost to do operations (paid by sender of the transaction)
    // - gas * gasPrice = total fee
    .send({ from: accounts[0], gas: "1000000" });
  //=> proimse that resolves to transaction hash (like a receipt)
});

describe("Lottery Contract", () => {
  it("deploys a contract", () => {
    // console.log(accounts);
    // console.log(lottery);
    // presence of an address is a good way to check for presence of a contract
    // - assert.ok( ), does what you pass into the assert.ok exist
    assert.ok(lottery.options.address);
  });

  it("allows one account to enter", async () => {
    // enter 1st address in lottery
    // - .send() means we are sending a transaction (i.e. modifying data on the contract)
    // - takes in obj, that requires who is going to pay (from: address)
    // - we're having 1st account in accounts pay for transaction
    // - send() => returns promise that resolves to transaction hash (like receipt)
    // - if everything goes ok, then no errors will occur
    await lottery.methods.enter().send({
      // who is attempting to enter()
      from: accounts[0],

      // value: amount in wei that we want to send along
      value: web3.utils.toWei("0.02", "ether"), // convert .02 ether to wei
    });

    const players = await lottery.methods.getPlayers().call({
      from: accounts[0],
    });

    // make sure correct address is stored in players
    assert.equal(accounts[0], players[0]);

    // make sure only 1 address in array (bec only 1 player entered so far)
    assert.equal(1, players.length); // value expected, value actual
  });

  it("allows multiple accounts to enter", async () => {
    await lottery.methods.enter().send({
      from: accounts[0],
      value: web3.utils.toWei("0.02", "ether"),
    });

    await lottery.methods.enter().send({
      from: accounts[1],
      value: web3.utils.toWei("0.02", "ether"),
    });

    await lottery.methods.enter().send({
      from: accounts[2],
      value: web3.utils.toWei("0.02", "ether"),
    });

    const players = await lottery.methods.getPlayers().call({
      from: accounts[0],
    });

    // make sure correct address is stored in players
    assert.equal(accounts[0], players[0]);
    assert.equal(accounts[1], players[1]);
    assert.equal(accounts[2], players[2]);

    // make sure only 3 addresses in array
    assert.equal(3, players.length); // value expected, value actual
  });

  it("requires a minimum amount of ether to enter", async () => {
    try {
      // we want to get an error, if we don't our method didn't work/validate!
      await lottery.methods.enter().send({
        from: accounts[0],
        value: 200, // wei
      });
    } catch (err) {
      assert(err); // returns true if error is truthy value (assert.ok checks for existence)
      return;
    }

    // if we didn't get an error from try block above, that means we failed
    assert(false);
  });

  it("only manager can call pickWinner", async () => {
    // enter non manager
    await lottery.methods.enter().send({
      from: accounts[1],
      value: web3.utils.toWei(".02", "ether"),
    });

    try {
      await lottery.methods.pickWinner().send({ from: accounts[1] });
    } catch (err) {
      assert(err);
      return;
    }

    assert(false);
  });

  it("sends money to the winner and resets the players array", async () => {
    await lottery.methods.enter().send({
      from: accounts[0],
      value: web3.utils.toWei("2", "ether"), // amount person is wagering (wei)
    });

    // retrieve account balance before pick winner and after
    const initialBalance = await web3.eth.getBalance(accounts[0]); // (wei)

    await lottery.methods.pickWinner().send({ from: accounts[0] });

    const finalBalance = await web3.eth.getBalance(accounts[0]); // (wei)

    const difference = finalBalance - initialBalance;

    assert(difference > web3.utils.toWei("1.8", "ether")); // 1.8 to allow for some gas cost
  });
});
