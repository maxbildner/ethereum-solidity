// import node.js library that allows us to run tests
const assert = require("assert");

// serves as our local ethereum test network
const ganache = require("ganache-cli");

// note Web3 is uppercase!! bec. we are importing a constructor function
//   used to create instances of the web3 library
const Web3 = require("web3");

// create an instance of Web3, pass in a PROVIDER
// PROVIDER = way to communicate between a web3 instance and a specific ethereum network
const web3 = new Web3(ganache.provider());

// import 2 compiled smart contract outputs (machine code as json)
// - each compiled json has the contract bytecode and interface (abi)
const compiledFactory = require("../ethereum/build/CampaignFactory.json");
const compiledCampaign = require("../ethereum/build/Campaign.json");

let accounts; // all unlocked account addressses/generated by ganache-cli
let factory; // reference to deployed instance of factory we're going to make
let campaignAddress;
let campaign;

// CAMPAIGN CONTRACT TESTS ******************************************************************
// - beforeEach callback will run before each it block within the beforeEach's scope,
//   but not outside of the beforeEach's scope
beforeEach(async () => {
  // Get a list of all accounts (unlocked = can freely send/receive ether)
  accounts = await web3.eth.getAccounts(); // 10 generated "fake" accounts
  // => returns a promise that resolves to a list of accounts

  // Use one of those accounts to deploy the contract
  // create a JS instance of a factory contract
  // - interface tells web3 what methods the factory contract has
  //    - has a methods property (with methods defined in the .sol file)
  //    - has options property (with info about the contract like address, gasPrice, gas, ...)
  factory = await new web3.eth.Contract(JSON.parse(compiledFactory.interface))

    // tells web3 that we want to deploy a new contract
    // - data and arguments are properties of a transaction object
    // - arguments is list of arguments thats passed into contructor function of contract
    .deploy({ data: compiledFactory.bytecode }) //=> transaction object

    // tells web3 to send out a transaction that creates this contract
    // - gas = quantity of how much it'll cost to do operations (paid by sender of the transaction)
    // - gas * gasPrice = total fee
    .send({ from: accounts[0], gas: "1000000" }); // arbitrarily put 1m
  //=> proimse that resolves to transaction hash (like a receipt)

  await factory.methods
    .createCampaign("100") // 100 wei = min campaign contribution
    .send({
      from: accounts[0], // manager of campaign
      gas: "1000000",
    });

  // take first element that's returned from await array and assign it to campaignAddress
  [campaignAddress] = await factory.methods.getDeployedCampaigns().call();
  // same as below:
  //  const addresses = await factory.methods.getDeployedCampaigns().call();
  //  campaignAddress = addresses[0];
  // // addresses == array of addresses that we have for deployed campaigns

  // already deployed version of campaign contract
  campaign = await new web3.eth.Contract(
    JSON.parse(compiledCampaign.interface),
    campaignAddress
  );
});

describe("Campaign Contract", () => {
  it("deploys a Campaign Contract", () => {
    // presence of an address is a good way to check for presence of a contract
    // - assert.ok( ), does what you pass into the assert.ok exist
    assert.ok(campaign.options.address);
  });

  // person who called createCampaign on the factory has to be manager
  it("marks caller as the campaign manager", async () => {
    const manager = await campaign.methods.manager().call();
    assert.equal(accounts[0], manager);
  });

  describe("#contribute()", () => {
    // campaign has min contribution tied to it
    it("should not allow people to contribute less than the minimum contribution", async () => {
      try {
        // call campaigns contribute function and send in 5 wei (below minimum), we should error out if our code is correct
        await campaign.methods.contribute().send({
          value: "5", // (wei)- this is below the 100 minimum contribution!
          from: accounts[1],
        });
      } catch (err) {
        assert(err);
        return;
      }

      assert(false);
    });

    it("allows people to contribute money and marks them as approvers", async () => {
      await campaign.methods.contribute().send({
        value: "200", // wei (contribution amount)
        from: accounts[1],
      });

      // approvers is a mapping (similar to JS obejct), but we can NOT retrieve entire mapping, only 1 key/value
      const isContributor = await campaign.methods
        .approvers(accounts[1])
        .call();

      // assert will fail if argument evaluates to falsey value
      assert(isContributor);
    });

    it("increases the totalContributions attribute by the value sent in the tx object", async () => {
      let totalContributionsBefore = await campaign.methods
        .totalContributions()
        .call();
      // console.log(totalContributionsBefore);  //=> 0

      let contributionAmount = 200;
      await campaign.methods.contribute().send({
        value: contributionAmount, // wei
        from: accounts[1],
      });

      let totalContributionsAfter = await campaign.methods
        .totalContributions()
        .call();
      // console.log(totalContributionsAfter); //=> 200

      assert.equal(
        totalContributionsAfter - totalContributionsBefore,
        contributionAmount
      );
    });

    it("increases approversCount only by 1 no matter how many times the user contributes", async () => {
      let approversCountBefore = await campaign.methods.approversCount().call(); // approversCount() == num of unique donators
      // console.log(approversCountBefore);  //=> 0

      // person from account[1] donates 200 wei
      await campaign.methods.contribute().send({
        value: "200", // wei (contribution amount)
        from: accounts[1],
      });

      let approversCountAfter = await campaign.methods.approversCount().call();
      // console.log(approversCountAfter); //=> "1"

      // person from account[1] donates another 200 wei
      await campaign.methods.contribute().send({
        value: "200",
        from: accounts[1],
      });

      approversCountAfter = await campaign.methods.approversCount().call();
      // console.log(approversCountAfter); //=> "1"

      assert(Number(approversCountAfter) === 1);
    });
  });

  describe("#createRequest()", () => {
    it("throws error if function is sent by non manager", async () => {
      let recipient = accounts[1]; // address of vendor we want to send wei to
      let randomPerson = accounts[2]; // NOT the manager!

      try {
        // try creating request NOT as a manager (we should hit catch statement)
        await campaign.methods
          .createRequest("buy batteries", 100, recipient)
          .send({
            from: randomPerson, // NOT the manager
            gas: "1000000", // 1m
          });
      } catch (err) {
        assert(err);
        return;
      }

      // if we're here, that means out code is wrong!
      assert(false);
    });

    // does not throw error if function is sent by non manager
    it("allows a manager to make a payment request", async () => {
      let manager = await campaign.methods.manager().call(); // accounts[0]
      let recipient = accounts[1]; // address of vendor we want to send wei to
      let randomPerson = accounts[2]; // NOT the manager!

      await campaign.methods
        .createRequest(
          "Buy batteries",
          "100", // costs 100 wei to buy batteries
          recipient
        )
        .send({
          from: manager,
          gas: "1000000", // arbitrarily put 1m
        });

      // grab first request object in requests array
      const request = await campaign.methods.requests(0).call();

      assert.equal("Buy batteries", request.description);
    });

    // this would be like sending the manager sending money to themselves
    it("recipient of request cannot be the manager", async () => {
      let manager = await campaign.methods.manager().call(); // accounts[0]

      try {
        // try sending request as the manager (we should error out if our code is correct)
        await campaign.methods.createRequest("Pay myself", 100, manager).send({
          from: manager,
          gas: "1000000",
        });
      } catch (err) {
        assert(err);
        return;
      }

      // if we're here that means our code is wrong
      assert(false);
    });
  });

  describe("#approveRequest()", () => {
    // only donors can approve requests
    it("should throw error if non donator (approver) tries to approve request", async () => {
      let manager = accounts[0];
      let donator1 = accounts[1];
      let recipient = accounts[2];

      // donator1 contributes 200 wei to campaign
      await campaign.methods.contribute().send({
        from: donator1,
        value: 200,
      });

      // manager creates payment request to recipient
      await campaign.methods
        .createRequest("buy batteries", 100, recipient)
        .send({
          from: manager,
          gas: "1000000",
        });

      // try approving the first request as a non donator (ex. recipient)
      try {
        await campaign.methods.approveRequest(0).send({
          from: recipient, // NON DONATOR!!!
          gas: "1000000",
        });

        // we should error out if our code is correct
      } catch (err) {
        assert(err);
        return;
      }

      // if we're here, our smart contract code is incorrect!
      assert(false);
    });

    // should not throw error if a donator approves a request the first time
    it("make sure donators don't vote twice on a request", async () => {
      let manager = accounts[0];
      let donator1 = accounts[1];
      let recipient = accounts[2];

      // donator1 contributes 200 wei to campaign
      await campaign.methods.contribute().send({
        from: donator1,
        value: 200,
      });

      // manager creates payment request to recipient
      await campaign.methods
        .createRequest("buy batteries", 100, recipient)
        .send({
          from: manager,
          gas: "1000000",
        });

      // donator 1 approves request
      await campaign.methods.approveRequest(0).send({
        from: donator1, // valid donator
        gas: "1000000",
      });

      // get request at index 0 (there should only be 1 request)
      let request = await campaign.methods.requests(0).call();
      // console.log(request.approvals); // => undefined, we cannot access a mapping!!!

      // donator1 tries making another illegal approval for this request
      try {
        await campaign.methods.approveRequest(0).send({
          from: donator1,
          gas: "1000000",
        });

        // we should error out if our code is correct
      } catch (err) {
        assert(err && String(request.approvalCount) === "1");
        return;
      }

      // if we're here, our smart contract code is incorrect!
      assert(false);
    });
  });

  describe("#finalizeRequest()", () => {
    let manager;
    let donator1;
    let recipient;

    beforeEach(async () => {
      manager = accounts[0];
      donator1 = accounts[1];
      recipient = accounts[2];

      // donator1 makes 100 wei donation
      await campaign.methods.contribute().send({
        value: 100,
        from: donator1,
      });

      // manager creates spending request to recipient
      await campaign.methods
        .createRequest("data subscription", 100, recipient)
        .send({
          from: manager,
          gas: "1000000",
        });

      // first request in requests array
      let request = await campaign.methods.requests(0).call();

      // donator1 approves request
      await campaign.methods.approveRequest(0).send({
        from: donator1,
        gas: "1000000",
      });
    });

    it("can only be executed by manager", async () => {
      // try finalizing request as non manager
      try {
        await campaign.methods.finalizeRequest(0).send({
          from: donator1, // not the manager!
        });

        // we should error out if our code is correct
      } catch (err) {
        assert(err);
        return;
      }

      assert(false);
    });

    // it("more than 50% of donators must have approved this request", async () => {});

    // it("will run only if request has not already been finalized", async () => {});

    // it("shows error if campaign funds not enough to send to recipient", async () => {});

    // it("sends money to vendor (recipient)", async () => {});
  });

  it("processes requests", async () => {
    await campaign.methods.contribute().send({
      from: accounts[0],
      value: web3.utils.toWei("10", "ether"), // use 10 ether because easier to compare large transactions than small ones
    });

    await campaign.methods
      .createRequest(
        "Buy computer",
        web3.utils.toWei("5", "ether"),
        accounts[1]
      )
      .send({
        from: accounts[0],
        gas: "1000000",
      });

    await campaign.methods.approveRequest(0).send({
      from: accounts[0],
      gas: "1000000",
    });

    await campaign.methods.finalizeRequest(0).send({
      from: accounts[0], // accounts[0] bec. only manager can finalize a request
      gas: "1000000",
    });

    // retrieve balance of accounts[1] and make sure it has 5 ether
    let balance = await web3.eth.getBalance(accounts[1]); // string, wei
    balance = web3.utils.fromWei(balance, "ether"); // convert wei to ether
    balance = parseFloat(balance); // turn string into number
    // console.log(balance); //=> 104.9997 because we used this account earlier in a test

    assert(balance > 103); // ether
  });
});

// TO DO:
// CAMPAIGN CONTRACT METHODS:
// #contribute()
// - should not allow people to contribute less than the minimum contribution       DONE
// - allows people to contribute money and marks them as .approvers                 DONE
// - increases the totalContributions attribute by the value sent in the tx object  DONE
// - user contributing multiple times only increases approversCount by 1            DONE

// #createRequest()
// - can only be executed/sent by by the manager                                    DONE
// - recipient of new request cannot be the manager                                 DONE

// #approveRequest()
// - only donators can approve a request                                            DONE
// - people can only vote once! (can contribute multiple times)                     DONE

// #finalizeRequest()
// - can only be executed by manager                                                DONE
// - more than 50% of donators must have approved this request
// - will run only if request has not already been finalized
// - shows error if campaign funds not enough to send to recipient
// - sends money to vendor (recipient)

// #getSummary()
// - returns object (keys0,1,2,3,4 and values info about current campaign instance)

// #getRequestsCount()
// - returns length of requests array
