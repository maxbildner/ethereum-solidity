// import node.js library that allows us to run tests
const assert = require("assert");

// serves as our local ethereum test network
const ganache = require("ganache-cli");

// note Web3 is uppercase!! bec. we are importing a constructor function
//   used to create instances of the web3 library
const Web3 = require("web3");

// create an instance of Web3, pass in a PROVIDER
// PROVIDER = way to communicate between a web3 instance and a specific ethereum network
const web3 = new Web3(ganache.provider());

// import 2 compiled smart contract outputs (machine code as json)
// - each compiled json has the contract bytecode and interface (abi)
const compiledFactory = require("../ethereum/build/CampaignFactory.json");
const compiledCampaign = require("../ethereum/build/Campaign.json");

let accounts; // all unlocked account addressses/generated by ganache-cli
let factory; // reference to deployed instance of factory we're going to make
let campaignAddress;
let campaign;

// CAMPAIGN CONTRACT TESTS ******************************************************************
// cb will run before each it block
beforeEach(async () => {
  // Get a list of all accounts (unlocked = can freely send/receive ether)
  accounts = await web3.eth.getAccounts(); // 10 generated "fake" accounts
  // => returns a promise that resolves to a list of accounts

  // Use one of those accounts to deploy the contract
  // create a JS instance of a factory contract
  // - interface tells web3 what methods the factory contract has
  //    - has a methods property (with methods defined in the .sol file)
  //    - has options property (with info about the contract like address, gasPrice, gas, ...)
  factory = await new web3.eth.Contract(JSON.parse(compiledFactory.interface))

    // tells web3 that we want to deploy a new contract
    // - data and arguments are properties of a transaction object
    // - arguments is list of arguments thats passed into contructor function of contract
    .deploy({ data: compiledFactory.bytecode }) //=> transaction object

    // tells web3 to send out a transaction that creates this contract
    // - gas = quantity of how much it'll cost to do operations (paid by sender of the transaction)
    // - gas * gasPrice = total fee
    .send({ from: accounts[0], gas: "1000000" }); // arbitrarily put 1m
  //=> proimse that resolves to transaction hash (like a receipt)

  await factory.methods
    .createCampaign("100") // 100 wei = min campaign contribution
    .send({
      from: accounts[0], // manager of campaign
      gas: "1000000",
    });

  // take first element that's returned from await array and assign it to campaignAddress
  [campaignAddress] = await factory.methods.getDeployedCampaigns().call();
  // same as below:
  //  const addresses = await factory.methods.getDeployedCampaigns().call();
  //  campaignAddress = addresses[0];
  // // addresses == array of addresses that we have for deployed campaigns

  // already deployed version of campaign contract
  campaign = await new web3.eth.Contract(
    JSON.parse(compiledCampaign.interface),
    campaignAddress
  );
});

describe("Campaigns", () => {
  it("deploys a factory and a campaign", () => {
    // presence of an address is a good way to check for presence of a contract
    // - assert.ok( ), does what you pass into the assert.ok exist
    assert.ok(factory.options.address);
    assert.ok(campaign.options.address);
  });

  // person who called createCampaign on the factory has to be manager
  it("marks caller as the campaign manager", async () => {
    const manager = await campaign.methods.manager().call();
    assert.equal(accounts[0], manager);
  });

  it("allows people to contribute money and marks them as approvers", async () => {
    await campaign.methods.contribute().send({
      value: "200", // wei
      from: accounts[1],
    });

    // approvers is a mapping (similar to JS obejct), but we can NOT retrieve entire mapping, only 1 key/value
    const isContributor = await campaign.methods.approvers(accounts[1]).call();

    // assert will fail if we argument evaluates to falsey value
    assert(isContributor);
  });

  // campaign has min contribution tied to it
  it("requires a minimum contribution", async () => {
    // call campaigns contribute function and send in 100 wei
    try {
      await campaign.methods.contribute().send({
        value: "5",
        from: accounts[1],
      });
    } catch (err) {
      assert(err);
      return;
    }

    assert(false);
  });

  it("allows a manager to make a payment request", async () => {
    await campaign.methods
      .createRequest(
        "Buy batteries",
        "100", // costs 100 wei to buy batteries
        accounts[2] // address of vendor we want to send wei to
      )
      .send({
        from: accounts[0], // manager address
        gas: "1000000", // arbitrarily put 1m
      });

    // grab first request object in requests array
    const request = await campaign.methods.requests(0).call();

    assert.equal("Buy batteries", request.description);
  });

  it("processes requests", async () => {
    await campaign.methods.contribute().send({
      from: accounts[0],
      value: web3.utils.toWei("10", "ether"), // use 10 ether because easier to compare large transactions than small ones
    });

    await campaign.methods
      .createRequest(
        "Buy computer",
        web3.utils.toWei("5", "ether"),
        accounts[1]
      )
      .send({
        from: accounts[0],
        gas: "1000000",
      });

    await campaign.methods.approveRequest(0).send({
      from: accounts[0],
      gas: "1000000",
    });

    await campaign.methods.finalizeRequest(0).send({
      from: accounts[0], // accounts[0] bec. only manager can finalize a request
      gas: "1000000",
    });

    // retrieve balance of accounts[1] and make sure it has 5 ether
    let balance = await web3.eth.getBalance(accounts[1]); // string, wei
    balance = web3.utils.fromWei(balance, "ether"); // convert wei to ether
    balance = parseFloat(balance); // turn string into number
    // console.log(balance); //=> 104.9997 because we used this account earlier in a test

    assert(balance > 103); // ether
  });
});

// TO DO:
// CAMPAIGN CONTRACT
// contribute
// - user contributing multiple times only increases approversCount by 1
// - user can contribute multiple times, but only vote once

// createRequest
// - can only be executed/sent by by the manager
// - recipient of new request cannot be the manager

// approveRequest
// - only donators can approve a request
// - people can only vote once!

// finalizeRequest
// - can only be executed by manager
// - more than 50% of donators must have approved this request
// - will run only if request has not already been finalized
// - shows error if campaign funds not enough to send to recipient
// - sends money to vendor (recipient)
